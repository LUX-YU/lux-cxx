# ===========================================
# Include guard
# ===========================================
if(_COMPONENT_META_TOOLS_INCLUDED_)
  return()
endif()
set(_COMPONENT_META_TOOLS_INCLUDED_ TRUE)

# -------------------------------------------------
# add_meta:
#   Defines a meta information generation object. Parameters (required/optional):
#
#   Required parameters (one_value_args):
#       NAME                <MetaObjectName>        -- Unique name for storing target properties and later use.
#       MARKER              <marker>                -- Annotation marker for C++ declarations.
#       TEMPLATE            <template_path>         -- Custom generation template path (using inja syntax).
#       OUT_DIR             <out_dir>               -- Output directory for generated files.
#       COMPILE_COMMANDS    <compile_commands>      -- Path to compile_commands file (usually generated by the build system).
#       META_SUFFIX         <meta_suffix>           -- Suffix for the generated meta information files.
#       SOURCE_FILE         <source_file>           -- Source file from compile_commands used to locate the compile options (if empty, supply options via EXTRA_COMPILE_OPTIONS).
#       SERIAL_META         <ON/OFF>                -- Whether to serialize parsed meta information to a JSON file (default is ON).
#       DRY_RUN             <ON/OFF>                -- Whether to perform a dry run (no files generated).
#
#   Multi-value parameters (multi_value_args):
#       TARGET_FILES        file1.hpp file2.hpp ...   -- List of files to generate meta information for.
#       EXTRA_COMPILE_OPTIONS <option1> <option2> ...  -- Additional compile options.
#
#   Optional parameters:
#       ECHO                -- Print verbose information (for debugging).
#       ALWAYS_REGENERATE   -- Force regeneration every time.
#
function(add_meta)
    set(one_value_args
        NAME
        GENERATOR
        MARKER
        TEMPLATE
        OUT_DIR
        COMPILE_COMMANDS
        META_SUFFIX
        SOURCE_FILE
        SERIAL_META
        DRY_RUN
    )
    set(multi_value_args
        TARGET_FILES
        EXTRA_COMPILE_OPTIONS
    )
    set(optional_args ECHO ALWAYS_REGENERATE)
    cmake_parse_arguments(ARGS "${optional_args}" "${one_value_args}" "${multi_value_args}" ${ARGN})

    if(NOT ARGS_NAME)
        message(FATAL_ERROR "[add_meta] NAME parameter is required")
    endif()

    set(_meta_name "${ARGS_NAME}")

    if(TARGET ${_meta_name})
        message(WARNING "[add_meta] Target '${_meta_name}' already exists; its properties will be overwritten.")
    else()
        add_custom_target(${_meta_name} ALL
            COMMENT "[add_meta] Placeholder target for meta object '${_meta_name}'."
        )
    endif()

    # Set default values
    if(NOT ARGS_OUT_DIR)
        set(ARGS_OUT_DIR "${CMAKE_BINARY_DIR}/metagen")
    endif()
    if(NOT ARGS_COMPILE_COMMANDS)
        set(ARGS_COMPILE_COMMANDS "${CMAKE_BINARY_DIR}/compile_commands.json")
        if(NOT EXISTS ${ARGS_COMPILE_COMMANDS})
            message(FATAL_ERROR "[add_meta] COMPILE_COMMANDS file not found: ${ARGS_COMPILE_COMMANDS}. Please generate it with your build system.")
        endif()
    endif()
    if(NOT ARGS_META_SUFFIX)
        set(ARGS_META_SUFFIX ".meta.cpp")
    endif()
    if(NOT ARGS_SOURCE_FILE)
        set(ARGS_SOURCE_FILE "")  # If empty, please supply compile options via EXTRA_COMPILE_OPTIONS.
    endif()
    if(NOT ARGS_SERIAL_META)
        set(ARGS_SERIAL_META ON)
    endif()
    if(NOT ARGS_DRY_RUN)
        set(ARGS_DRY_RUN OFF)
    endif()

    # Locate the generator executable "lux_meta_generator"
    if(NOT ARGS_GENERATOR)
        find_program(LUX_META_GENERATOR lux_meta_generator REQUIRED)
        if(NOT LUX_META_GENERATOR)
            message(FATAL_ERROR "[target_add_meta] Could not find the lux_meta_generator executable")
        endif()
    else()
        set(LUX_META_GENERATOR "${ARGS_GENERATOR}")
        message(STATUS "Use user-provided generator: ${LUX_META_GENERATOR}")
    endif()

    # Store configuration in target properties (prefix properties with META_)
    set_target_properties(${_meta_name} PROPERTIES
        META_GENERATOR              "${LUX_META_GENERATOR}"
        META_MARKER                 "${ARGS_MARKER}"
        META_TEMPLATE_PATH          "${ARGS_TEMPLATE}"
        META_OUT_DIR                "${ARGS_OUT_DIR}"
        META_COMPILE_COMMANDS       "${ARGS_COMPILE_COMMANDS}"
        META_TARGET_FILES           "${ARGS_TARGET_FILES}"
        META_META_SUFFIX            "${ARGS_META_SUFFIX}"
        META_SOURCE_FILE            "${ARGS_SOURCE_FILE}"
        META_EXTRA_COMPILE_OPTIONS  "${ARGS_EXTRA_COMPILE_OPTIONS}"
        META_SERIAL_META            "${ARGS_SERIAL_META}"
        META_DRY_RUN                "${ARGS_DRY_RUN}"
        META_ECHO                   "${ARGS_ECHO}"
    )
endfunction()

# -------------------------------------------------
# meta_add_files:
#   Appends additional files to the TARGET_FILES property of the specified meta object.
#   Usage:
#       meta_add_files(<MetaObjectName> TARGET_FILES file1.hpp file2.hpp ...)
#
function(meta_add_files)
    if("${ARGV0}" STREQUAL "")
        message(FATAL_ERROR "[meta_add_files] The first argument must be the MetaObjectName")
    endif()
    set(_meta_name "${ARGV0}")
    list(REMOVE_AT ARGV 0)
    if(NOT ARGV)
        message(FATAL_ERROR "[meta_add_files] At least one TARGET_FILES parameter is required")
    endif()
    get_target_property(_existing_files ${_meta_name} META_TARGET_FILES)
    if(NOT _existing_files)
        set(_existing_files "")
    endif()
    list(APPEND _existing_files ${ARGV})
    list(REMOVE_DUPLICATES _existing_files)
    set_target_properties(${_meta_name} PROPERTIES
        META_TARGET_FILES "${_existing_files}"
    )
endfunction()

# -------------------------------------------------
# target_add_meta:
#   Reads the TARGET_FILES information from the Meta object, writes a JSON configuration file,
#   calls the generator executable to produce output files, and adds the generated files to the target.
#
#   Usage:
#       target_add_meta(
#           NAME   <MetaObjectName>
#           TARGET <YourTarget>
#           [ALWAYS_REGENERATE]
#           [ECHO]
#       )
function(target_add_meta)
    set(one_value_args NAME TARGET)
    set(optional_args ALWAYS_REGENERATE ECHO DONT_ADD_TO_SOURCE)
    cmake_parse_arguments(ARGS "" "${one_value_args}" "" ${ARGN})

    if(NOT ARGS_NAME)
        message(FATAL_ERROR "[target_add_meta] NAME parameter is required")
    endif()
    if(NOT ARGS_TARGET)
        message(FATAL_ERROR "[target_add_meta] TARGET parameter is required")
    endif()

    set(_meta_name "${ARGS_NAME}")
    set(_target_name "${ARGS_TARGET}")

    # Retrieve configuration from the Meta object
    get_target_property(_meta_out_dir  ${_meta_name} META_OUT_DIR)
    get_target_property(_meta_cc_json  ${_meta_name} META_COMPILE_COMMANDS)
    get_target_property(_meta_template ${_meta_name} META_TEMPLATE_PATH)
    get_target_property(_meta_marker   ${_meta_name} META_MARKER)
    get_target_property(_meta_target_files ${_meta_name} META_TARGET_FILES)
    get_target_property(_meta_meta_suffix ${_meta_name} META_META_SUFFIX)
    get_target_property(_meta_source_file ${_meta_name} META_SOURCE_FILE)
    get_target_property(_meta_extra_compile_options ${_meta_name} META_EXTRA_COMPILE_OPTIONS)
    get_target_property(_meta_serial_meta ${_meta_name} META_SERIAL_META)
    get_target_property(_meta_dry_run ${_meta_name} META_DRY_RUN)
    get_target_property(_meta_echo   ${_meta_name} META_ECHO)
    get_target_property(_meta_gen_exe ${_meta_name} META_GENERATOR)

    if(NOT _meta_out_dir)
        set(_meta_out_dir "${CMAKE_BINARY_DIR}/metagen")
    endif()
    if(NOT _meta_cc_json)
        set(_meta_cc_json "${CMAKE_BINARY_DIR}/compile_commands.json")
    endif()
    if(NOT _meta_template)
        message(FATAL_ERROR "[target_add_meta] META_TEMPLATE_PATH (TEMPLATE parameter) is not provided in ${_meta_name}")
    endif()
    if(NOT _meta_meta_suffix)
        set(_meta_meta_suffix ".meta.cpp")
    endif()
    if(NOT _meta_serial_meta)
        set(_meta_serial_meta ON)
    endif()
    if(NOT _meta_dry_run)
        set(_meta_dry_run OFF)
    endif()

    # Get target source files to determine the entry source for compile_commands
    get_target_property(_srcs "${_target_name}" SOURCES)
    if(NOT _srcs OR _srcs STREQUAL "NOTFOUND")
        message(WARNING "[target_add_meta] Target '${_target_name}' has no sources; using empty string for source_file.")
        set(_main_src "")
    else()
        set(_main_src "")
        foreach(_s IN LISTS _srcs)
            get_filename_component(_ext "${_s}" EXT)
            if(_ext STREQUAL ".cpp" OR _ext STREQUAL ".cxx" OR _ext STREQUAL ".cc")
                set(_main_src "${_s}")
                break()
            endif()
        endforeach()
        if(_main_src STREQUAL "")
            message(WARNING "[target_add_meta] No .cpp file found in target '${_target_name}'; passing empty source_file.")
        endif()
    endif()

    if(NOT _meta_target_files)
        message(FATAL_ERROR "[target_add_meta] The TARGET_FILES (META_TARGET_FILES) for '${_meta_name}' is empty.")
    endif()
    # Convert _meta_target_files (semicolon-separated) to a list
    set(_meta_files ${_meta_target_files})

    # Generate JSON configuration file with new parameters
    set(_config_file "${_meta_out_dir}/${_meta_name}_meta_config.json")
    file(WRITE "${_config_file}" "{\n")
    file(APPEND "${_config_file}" "  \"marker\": \"${_meta_marker}\",\n")
    file(APPEND "${_config_file}" "  \"template_path\": \"${_meta_template}\",\n")
    file(APPEND "${_config_file}" "  \"out_dir\": \"${_meta_out_dir}\",\n")
    file(APPEND "${_config_file}" "  \"compile_commands\": \"${_meta_cc_json}\",\n")
    file(APPEND "${_config_file}" "  \"source_file\": \"${_main_src}\",\n")
    file(APPEND "${_config_file}" "  \"target_files\": [\n")
    list(LENGTH _meta_files _mf_len)
    math(EXPR _last_idx "${_mf_len} - 1")
    foreach(i RANGE 0 ${_last_idx})
        list(GET _meta_files ${i} mf)
        if(i LESS _last_idx)
            file(APPEND "${_config_file}" "    \"${mf}\",\n")
        else()
            file(APPEND "${_config_file}" "    \"${mf}\"\n")
        endif()
    endforeach()
    file(APPEND "${_config_file}" "  ],\n")
    file(APPEND "${_config_file}" "  \"meta_suffix\": \"${_meta_meta_suffix}\",\n")
    file(APPEND "${_config_file}" "  \"extra_compile_options\": [\n")
    if(_meta_extra_compile_options)
        # Convert the semicolon-separated EXTRA_COMPILE_OPTIONS to a list and write each entry on a new line
        string(REPLACE ";" "\n" _compile_opts "${_meta_extra_compile_options}")
        separate_arguments(_compile_opts)
        list(LENGTH _compile_opts _co_len)
        math(EXPR _co_last "${_co_len} - 1")
        foreach(i RANGE 0 ${_co_last})
            list(GET _compile_opts ${i} opt)
            if(i LESS _co_last)
                file(APPEND "${_config_file}" "    \"${opt}\",\n")
            else()
                file(APPEND "${_config_file}" "    \"${opt}\"\n")
            endif()
        endforeach()
    endif()
    file(APPEND "${_config_file}" "  ],\n")

    if("${_meta_serial_meta}" STREQUAL "ON")
      set(serial_meta_value true)
    else()
      set(serial_meta_value false)
    endif()
    if("${_meta_dry_run}" STREQUAL "ON")
      set(dry_run_value true)
    else()
      set(dry_run_value false)
    endif()

    file(APPEND "${_config_file}" "  \"serial_meta\": ${serial_meta_value},\n")
    file(APPEND "${_config_file}" "  \"dry_run\": ${dry_run_value}\n")
    file(APPEND "${_config_file}" "}\n")

    # For each target file, generate an output file (assuming each input file produces one output file with <basename><meta_suffix>)
    set(_all_generated_files "")
    set(_generated_source_files "")
    foreach(_mf IN LISTS _meta_files)
        get_filename_component(_base "${_mf}" NAME_WE)
        set(_generated_file "${_meta_out_dir}/${_base}${_meta_meta_suffix}")
        list(APPEND _all_generated_files "${_generated_file}")
        # If meta_suffix contains .cpp, treat it as a source file.
        string(FIND "${_meta_meta_suffix}" ".cpp" pos)
        if(NOT pos EQUAL -1)
            list(APPEND _generated_source_files "${_generated_file}")
        endif()
    endforeach()

    if(_meta_echo)
        message(STATUS "[target_add_meta] META_OUT_DIR = ${_meta_out_dir}")
        message(STATUS "                 COMPILE_COMMANDS = ${_meta_cc_json}")
        message(STATUS "                 TEMPLATE = ${_meta_template}")
        message(STATUS "                 MARKER = ${_meta_marker}")
        message(STATUS "                 META_SUFFIX = ${_meta_meta_suffix}")
        message(STATUS "                 SOURCE_FILE = ${_main_src}")
        message(STATUS "                 TARGET_FILES:")
        foreach(gen_file IN LISTS _all_generated_files)
            message(STATUS "                 -> ${gen_file}")
        endforeach()
    endif()

    if(NOT EXISTS "${_meta_out_dir}")
        file(MAKE_DIRECTORY "${_meta_out_dir}")
    endif()

    # Add a custom command: when any input file changes, regenerate the outputs
    add_custom_command(
        OUTPUT ${_all_generated_files}
        COMMAND "${_meta_gen_exe}" "${_config_file}"
        DEPENDS ${_meta_files}
        COMMENT "[target_add_meta] Generating meta information for '${_meta_name}', command: ${_meta_gen_exe} ${_config_file}"
        VERBATIM
    )

    if(ARGS_ALWAYS_REGENERATE)
        foreach(_gf IN LISTS _all_generated_files)
            set_property(SOURCE "${_gf}" PROPERTY SKIP_CACHE TRUE)
        endforeach()
    endif()

    # Define a custom target
    set(_meta_gen_target "${_meta_name}_gen")
    add_custom_target("${_meta_gen_target}"
        DEPENDS ${_all_generated_files}
    )

    # Add generated source files to the user's target (if any .cpp files were generated)
    if(_generated_source_files AND NOT ARGS_DONT_ADD_TO_SOURCE)
        target_sources("${_target_name}" PRIVATE ${_generated_source_files})
    endif()
    add_dependencies("${_target_name}" "${_meta_gen_target}")
    target_include_directories("${_target_name}" PRIVATE "${_meta_out_dir}")

    message(STATUS "[target_add_meta] Done: '${_target_name}' will build meta information from '${_meta_name}'.")
endfunction()
