// reflection_auto_gen.cpp
#include <lux/cxx/dref/runtime/runtime_reflection.hpp>
#include <cstring>

namespace {{generated_namespace}} {

// ------------------------------
// 1) 为每个类的 成员函数 生成 "bridge invoker"
// ------------------------------
{{#classes}}
  {{#methods}}
static void {{class_name}}_{{method_name}}_invoker(void* pObj, void** args, void* pRetVal)
{
    // 将 pObj 转为具体类指针
    auto* realObj = static_cast<{{qualified_name}}*>(pObj);

    // 根据 params 依次拆解形参
    {{#params}}
    auto arg{{index}} = *static_cast<{{type_name}}*>( args[{{index}}] );
    {{/params}}

    {{#has_return_value}}
    auto retVal = realObj->{{method_name}}(
      {{#params}} arg{{index}}{{#has_next}}, {{/has_next}} {{/params}}
    );
    // 写回 *pRetVal
    *static_cast<{{return_type_name}}*>(pRetVal) = retVal;
    {{/has_return_value}}

    {{^has_return_value}}
    // void 函数
    realObj->{{method_name}}(
      {{#params}} arg{{index}}{{#has_next}}, {{/has_next}} {{/params}}
    );
    {{/has_return_value}}
}
  {{/methods}}
{{/classes}}

// ------------------------------
// 2) 声明静态的  FieldMeta / MethodMeta / ClassMeta
// ------------------------------
{{#classes}}

// ---- field metas
{{#fields}}
static ::lux::cxx::dref::runtime::FieldMeta s_{{class_name}}_field_{{field_name}}(
    &{{field_decl_pointer}}  // lan_model::FieldDeclaration*
);
{{/fields}}

// ---- method metas
{{#methods}}
static ::lux::cxx::dref::runtime::MethodMeta s_{{class_name}}_method_{{method_name}}(
    &{{method_decl_pointer}},  // lan_model::MemberFunctionDeclaration*
    &{{class_name}}_{{method_name}}_invoker
);
{{/methods}}

// ---- class meta
static ::lux::cxx::dref::runtime::ClassMeta s_{{class_name}}_class(
    &{{class_decl_pointer}}
);

// 先收集 fields / methods 到数组, initReflection() 里再赋值
static ::lux::cxx::dref::runtime::FieldMeta* s_{{class_name}}_fields[] = {
    {{#fields}} &s_{{class_name}}_field_{{field_name}}, {{/fields}}
};

static ::lux::cxx::dref::runtime::MethodMeta* s_{{class_name}}_methods[] = {
    {{#methods}} &s_{{class_name}}_method_{{method_name}}, {{/methods}}
};

{{/classes}}

// ------------------------------
// 3) initReflection()
// ------------------------------
void initReflection()
{
    auto& reg = ::lux::cxx::dref::runtime::GlobalRegistry();

    {{#classes}}
    // 将 s_{{class_name}}_fields / s_{{class_name}}_methods push_back 到 s_{{class_name}}_class
    s_{{class_name}}_class.fields.clear();
    for (auto* f : s_{{class_name}}_fields) {
        s_{{class_name}}_class.fields.push_back(*f);
    }

    s_{{class_name}}_class.methods.clear();
    for (auto* m : s_{{class_name}}_methods) {
        s_{{class_name}}_class.methods.push_back(*m);
    }

    // 注册
    reg.registerClass(&s_{{class_name}}_class);
    {{/classes}}
}

} // end namespace {{generated_namespace}}
